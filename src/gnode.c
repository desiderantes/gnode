/* gnode.c generated by valac 0.24.0, the Vala compiler
 * generated from gnode.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>
#include <cairo.h>


#define GNODE_TYPE_WINDOW (gnode_window_get_type ())
#define GNODE_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNODE_TYPE_WINDOW, GNodeWindow))
#define GNODE_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNODE_TYPE_WINDOW, GNodeWindowClass))
#define GNODE_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNODE_TYPE_WINDOW))
#define GNODE_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNODE_TYPE_WINDOW))
#define GNODE_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNODE_TYPE_WINDOW, GNodeWindowClass))

typedef struct _GNodeWindow GNodeWindow;
typedef struct _GNodeWindowClass GNodeWindowClass;
typedef struct _GNodeWindowPrivate GNodeWindowPrivate;

#define GNODE_TYPE_GRAPH (gnode_graph_get_type ())
#define GNODE_GRAPH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNODE_TYPE_GRAPH, GNodeGraph))
#define GNODE_GRAPH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNODE_TYPE_GRAPH, GNodeGraphClass))
#define GNODE_IS_GRAPH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNODE_TYPE_GRAPH))
#define GNODE_IS_GRAPH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNODE_TYPE_GRAPH))
#define GNODE_GRAPH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNODE_TYPE_GRAPH, GNodeGraphClass))

typedef struct _GNodeGraph GNodeGraph;
typedef struct _GNodeGraphClass GNodeGraphClass;

#define GNODE_TYPE_LINK (gnode_link_get_type ())
#define GNODE_LINK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNODE_TYPE_LINK, GNodeLink))
#define GNODE_LINK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNODE_TYPE_LINK, GNodeLinkClass))
#define GNODE_IS_LINK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNODE_TYPE_LINK))
#define GNODE_IS_LINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNODE_TYPE_LINK))
#define GNODE_LINK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNODE_TYPE_LINK, GNodeLinkClass))

typedef struct _GNodeLink GNodeLink;
typedef struct _GNodeLinkClass GNodeLinkClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GNODE_TYPE_APP (gnode_app_get_type ())
#define GNODE_APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNODE_TYPE_APP, GNodeApp))
#define GNODE_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNODE_TYPE_APP, GNodeAppClass))
#define GNODE_IS_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNODE_TYPE_APP))
#define GNODE_IS_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNODE_TYPE_APP))
#define GNODE_APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNODE_TYPE_APP, GNodeAppClass))

typedef struct _GNodeApp GNodeApp;
typedef struct _GNodeAppClass GNodeAppClass;

#define GNODE_TYPE_NODE (gnode_node_get_type ())
#define GNODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GNODE_TYPE_NODE, GNodeNode))
#define GNODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GNODE_TYPE_NODE, GNodeNodeClass))
#define GNODE_IS_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GNODE_TYPE_NODE))
#define GNODE_IS_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GNODE_TYPE_NODE))
#define GNODE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GNODE_TYPE_NODE, GNodeNodeClass))

typedef struct _GNodeNode GNodeNode;
typedef struct _GNodeNodeClass GNodeNodeClass;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _GNodeWindow {
	GtkApplicationWindow parent_instance;
	GNodeWindowPrivate * priv;
};

struct _GNodeWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _GNodeWindowPrivate {
	GtkMenu* menu;
	GtkTreeStore* treestore;
	GtkTreeView* view;
	GtkNotebook* notebook;
	GtkDrawingArea* node_area;
	GNodeGraph* graph;
	gboolean adding_node;
	gboolean adding_edge;
	gboolean cheapest_path;
	GeeArrayList* cheap_path;
};


static gpointer gnode_window_parent_class = NULL;

GType gnode_window_get_type (void) G_GNUC_CONST;
GType gnode_graph_get_type (void) G_GNUC_CONST;
GType gnode_link_get_type (void) G_GNUC_CONST;
#define GNODE_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GNODE_TYPE_WINDOW, GNodeWindowPrivate))
enum  {
	GNODE_WINDOW_DUMMY_PROPERTY
};
GType gnode_app_get_type (void) G_GNUC_CONST;
GNodeWindow* gnode_window_new (GNodeApp* parent);
GNodeWindow* gnode_window_construct (GType object_type, GNodeApp* parent);
GNodeGraph* gnode_graph_new (const gchar* title);
GNodeGraph* gnode_graph_construct (GType object_type, const gchar* title);
GType gnode_node_get_type (void) G_GNUC_CONST;
void gnode_graph_add_node (GNodeGraph* self, GNodeNode* node);
GNodeNode* gnode_node_new (const gchar* label, GNodeGraph* parent, gdouble x, gdouble y);
GNodeNode* gnode_node_construct (GType object_type, const gchar* label, GNodeGraph* parent, gdouble x, gdouble y);
static void gnode_window_setup_treeview (GNodeWindow* self);
const gchar* gnode_graph_get_title (GNodeGraph* self);
gboolean gnode_graph_is_connected (GNodeGraph* self);
void gnode_window_on_add_node (GNodeWindow* self);
void gnode_window_on_add_edge (GNodeWindow* self);
void gnode_window_on_remove_node (GNodeWindow* self);
void gnode_window_on_remove_edge (GNodeWindow* self);
gboolean gnode_window_node_draw (GNodeWindow* self, cairo_t* ctx);
void gnode_graph_draw (GNodeGraph* self, cairo_t* ctx);
static void gnode_window_finalize (GObject* obj);


GNodeWindow* gnode_window_construct (GType object_type, GNodeApp* parent) {
	GNodeWindow * self = NULL;
	GNodeGraph* _tmp0_ = NULL;
	GNodeApp* _tmp1_ = NULL;
	GtkDrawingArea* _tmp2_ = NULL;
	GNodeGraph* _tmp3_ = NULL;
	GNodeGraph* _tmp4_ = NULL;
	GNodeNode* _tmp5_ = NULL;
	GNodeNode* _tmp6_ = NULL;
	GNodeGraph* _tmp7_ = NULL;
	GNodeGraph* _tmp8_ = NULL;
	GNodeNode* _tmp9_ = NULL;
	GNodeNode* _tmp10_ = NULL;
	g_return_val_if_fail (parent != NULL, NULL);
	self = (GNodeWindow*) g_object_new (object_type, NULL);
	_tmp0_ = gnode_graph_new ("New Graph");
	_g_object_unref0 (self->priv->graph);
	self->priv->graph = _tmp0_;
	_tmp1_ = parent;
	gtk_window_set_application ((GtkWindow*) self, (GtkApplication*) _tmp1_);
	_tmp2_ = self->priv->node_area;
	gtk_widget_add_events ((GtkWidget*) _tmp2_, (gint) GDK_BUTTON_PRESS_MASK);
	self->priv->adding_node = FALSE;
	self->priv->adding_edge = FALSE;
	_g_object_unref0 (self->priv->cheap_path);
	self->priv->cheap_path = NULL;
	_tmp3_ = self->priv->graph;
	_tmp4_ = self->priv->graph;
	_tmp5_ = gnode_node_new ("test1", _tmp4_, (gdouble) 10, (gdouble) 10);
	_tmp6_ = _tmp5_;
	gnode_graph_add_node (_tmp3_, _tmp6_);
	_g_object_unref0 (_tmp6_);
	_tmp7_ = self->priv->graph;
	_tmp8_ = self->priv->graph;
	_tmp9_ = gnode_node_new ("test2", _tmp8_, (gdouble) 30, (gdouble) 30);
	_tmp10_ = _tmp9_;
	gnode_graph_add_node (_tmp7_, _tmp10_);
	_g_object_unref0 (_tmp10_);
	self->priv->cheapest_path = FALSE;
	return self;
}


GNodeWindow* gnode_window_new (GNodeApp* parent) {
	return gnode_window_construct (GNODE_TYPE_WINDOW, parent);
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


static void gnode_window_setup_treeview (GNodeWindow* self) {
	GtkTreeIter root = {0};
	GtkTreeIter info_iter = {0};
	GtkTreeIter value_iter = {0};
	GtkTreeStore* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	GtkTreeStore* _tmp2_ = NULL;
	GtkTreeIter _tmp3_ = {0};
	GNodeGraph* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	GtkTreeStore* _tmp7_ = NULL;
	GtkTreeIter _tmp8_ = {0};
	GtkTreeIter _tmp9_ = {0};
	GtkTreeStore* _tmp10_ = NULL;
	GtkTreeIter _tmp11_ = {0};
	GtkTreeStore* _tmp12_ = NULL;
	GtkTreeIter _tmp13_ = {0};
	GtkTreeIter _tmp14_ = {0};
	GtkTreeStore* _tmp15_ = NULL;
	GtkTreeIter _tmp16_ = {0};
	GNodeGraph* _tmp17_ = NULL;
	gboolean _tmp18_ = FALSE;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	GtkTreeStore* _tmp21_ = NULL;
	GtkTreeIter _tmp22_ = {0};
	GtkTreeIter _tmp23_ = {0};
	GtkTreeStore* _tmp24_ = NULL;
	GtkTreeIter _tmp25_ = {0};
	GtkTreeStore* _tmp26_ = NULL;
	GtkTreeIter _tmp27_ = {0};
	GtkTreeIter _tmp28_ = {0};
	GtkTreeStore* _tmp29_ = NULL;
	GtkTreeIter _tmp30_ = {0};
	GtkTreeStore* _tmp31_ = NULL;
	GtkTreeIter _tmp32_ = {0};
	GtkTreeIter _tmp33_ = {0};
	GtkTreeStore* _tmp34_ = NULL;
	GtkTreeIter _tmp35_ = {0};
	GtkTreeView* _tmp36_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->treestore;
	gtk_tree_store_append (_tmp0_, &_tmp1_, NULL);
	root = _tmp1_;
	_tmp2_ = self->priv->treestore;
	_tmp3_ = root;
	_tmp4_ = self->priv->graph;
	_tmp5_ = gnode_graph_get_title (_tmp4_);
	_tmp6_ = _tmp5_;
	gtk_tree_store_set (_tmp2_, &_tmp3_, 0, _tmp6_, -1, -1);
	_tmp7_ = self->priv->treestore;
	_tmp8_ = root;
	gtk_tree_store_append (_tmp7_, &_tmp9_, &_tmp8_);
	info_iter = _tmp9_;
	_tmp10_ = self->priv->treestore;
	_tmp11_ = info_iter;
	gtk_tree_store_set (_tmp10_, &_tmp11_, 0, "Basic Info", -1, -1);
	_tmp12_ = self->priv->treestore;
	_tmp13_ = info_iter;
	gtk_tree_store_append (_tmp12_, &_tmp14_, &_tmp13_);
	value_iter = _tmp14_;
	_tmp15_ = self->priv->treestore;
	_tmp16_ = value_iter;
	_tmp17_ = self->priv->graph;
	_tmp18_ = gnode_graph_is_connected (_tmp17_);
	_tmp19_ = bool_to_string (_tmp18_);
	_tmp20_ = _tmp19_;
	gtk_tree_store_set (_tmp15_, &_tmp16_, 0, "Connected", 1, _tmp20_, -1, -1);
	_g_free0 (_tmp20_);
	_tmp21_ = self->priv->treestore;
	_tmp22_ = info_iter;
	gtk_tree_store_append (_tmp21_, &_tmp23_, &_tmp22_);
	value_iter = _tmp23_;
	_tmp24_ = self->priv->treestore;
	_tmp25_ = value_iter;
	gtk_tree_store_set (_tmp24_, &_tmp25_, 0, "Heart of Darkness", 1, "$4.99", -1, -1);
	_tmp26_ = self->priv->treestore;
	_tmp27_ = info_iter;
	gtk_tree_store_append (_tmp26_, &_tmp28_, &_tmp27_);
	value_iter = _tmp28_;
	_tmp29_ = self->priv->treestore;
	_tmp30_ = value_iter;
	gtk_tree_store_set (_tmp29_, &_tmp30_, 0, "Ulysses", 1, "$26.09", -1, -1);
	_tmp31_ = self->priv->treestore;
	_tmp32_ = info_iter;
	gtk_tree_store_append (_tmp31_, &_tmp33_, &_tmp32_);
	value_iter = _tmp33_;
	_tmp34_ = self->priv->treestore;
	_tmp35_ = value_iter;
	gtk_tree_store_set (_tmp34_, &_tmp35_, 0, "Effective Vala", 1, "$38.99", -1, -1);
	_tmp36_ = self->priv->view;
	gtk_tree_view_expand_all (_tmp36_);
}


void gnode_window_on_add_node (GNodeWindow* self) {
	g_return_if_fail (self != NULL);
}


void gnode_window_on_add_edge (GNodeWindow* self) {
	g_return_if_fail (self != NULL);
}


void gnode_window_on_remove_node (GNodeWindow* self) {
	g_return_if_fail (self != NULL);
}


void gnode_window_on_remove_edge (GNodeWindow* self) {
	g_return_if_fail (self != NULL);
}


gboolean gnode_window_node_draw (GNodeWindow* self, cairo_t* ctx) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (ctx != NULL, FALSE);
	_tmp0_ = self->priv->adding_node;
	if (_tmp0_) {
	} else {
		gboolean _tmp1_ = FALSE;
		_tmp1_ = self->priv->adding_edge;
		if (_tmp1_) {
		} else {
			gboolean _tmp2_ = FALSE;
			_tmp2_ = self->priv->cheapest_path;
			if (_tmp2_) {
				GNodeGraph* _tmp3_ = NULL;
				cairo_t* _tmp4_ = NULL;
				_tmp3_ = self->priv->graph;
				_tmp4_ = ctx;
				gnode_graph_draw (_tmp3_, _tmp4_);
			}
		}
	}
	result = TRUE;
	return result;
}


static void gnode_window_class_init (GNodeWindowClass * klass) {
	gint GNodeWindow_private_offset;
	gnode_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GNodeWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = gnode_window_finalize;
	GNodeWindow_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/ui/gnode.ui");
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "menu", FALSE, GNodeWindow_private_offset + G_STRUCT_OFFSET (GNodeWindowPrivate, menu));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "treestore", FALSE, GNodeWindow_private_offset + G_STRUCT_OFFSET (GNodeWindowPrivate, treestore));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "view", FALSE, GNodeWindow_private_offset + G_STRUCT_OFFSET (GNodeWindowPrivate, view));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "notebook", FALSE, GNodeWindow_private_offset + G_STRUCT_OFFSET (GNodeWindowPrivate, notebook));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "node_area", FALSE, GNodeWindow_private_offset + G_STRUCT_OFFSET (GNodeWindowPrivate, node_area));
}


static void gnode_window_instance_init (GNodeWindow * self) {
	self->priv = GNODE_WINDOW_GET_PRIVATE (self);
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void gnode_window_finalize (GObject* obj) {
	GNodeWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GNODE_TYPE_WINDOW, GNodeWindow);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->priv->treestore);
	_g_object_unref0 (self->priv->view);
	_g_object_unref0 (self->priv->notebook);
	_g_object_unref0 (self->priv->node_area);
	_g_object_unref0 (self->priv->graph);
	_g_object_unref0 (self->priv->cheap_path);
	G_OBJECT_CLASS (gnode_window_parent_class)->finalize (obj);
}


GType gnode_window_get_type (void) {
	static volatile gsize gnode_window_type_id__volatile = 0;
	if (g_once_init_enter (&gnode_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GNodeWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnode_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GNodeWindow), 0, (GInstanceInitFunc) gnode_window_instance_init, NULL };
		GType gnode_window_type_id;
		gnode_window_type_id = g_type_register_static (GTK_TYPE_APPLICATION_WINDOW, "GNodeWindow", &g_define_type_info, 0);
		g_once_init_leave (&gnode_window_type_id__volatile, gnode_window_type_id);
	}
	return gnode_window_type_id__volatile;
}



